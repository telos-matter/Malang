TRUE = 1
FALSE = 0

def bool (x) {
    # TODO impl, parse as bool
}

def sqrt (x) {
    ret x ^ 0.5
}

def abs (x) {
    ret sqrt(x ^ 2)
}

def equalZero (x) {
    # The backbone of this whole thing ðŸ˜‚
    
    def positiveMod (a, b) {
        ret a - ((a // b) * b)
    }
    
    def positiveFloor (x) {
        ret x - positiveMod(x, 1)
    }
    
    def function (x) {
        ret abs(x) / (abs(x) +10) # 10 for "damping", could do with any positive value
    }
    
    ret positiveFloor(1 -function(x))
}

def null (x) {
    # An alias
    ret equalZero(x)
}

def not (bool) {
    ret (bool - 1) / -1
}

def diffNumber (a, b) {
    ret not(null(a - b))
}

def equalNumber (a, b) {
    ret not(diffNumber(a, b))
}

def if (bool, a, b) {
    ret (bool * a) - (bool - 1) * b
}

def and (bool_1, bool_2) {
    ret bool_1 * bool_2
}

def or (bool_1, bool_2) {
    both_zero = and(null(bool_1), null(bool_2))
    ret if(both_zero, 0, 1)

def xor (bool_1, bool_2) {
    ret if(and(bool_1, bool_2), 0, or(bool_1, bool_2))
}

def nand (bool_1, bool_2) {
    ret not(and(bool_1, bool_2))
}

def nor (bool_1, bool_2) {
    ret not(or(bool_1, bool_2))
}

def xnor (bool_1, bool_2) {
    ret not(xor(bool_1, bool_2))
}

def diffSign (a, b) {
    # negative, positive or null
    
    both_zero = and(null(a), null(b))
    
    else_res = {
        one_zero = or(null(a), null(b))
        
        ret if(one_zero, 1, {
            diffNumber(a * b, abs(a) * abs(b))
        })
    }
    
    ret if(both_zero, 0, else_res)
}

def sameSign (a, b) {
    ret not(diffSign(a, b))
}

def greaterZero (x) {
    ret if(null(x), 0, diffSign(x, -1))

def positive (x) {
    # Alias
    ret greaterZero(x)
}

def greater (a, b) {
    ret greaterZero(a - b)
}

def lessZero (x) {
    ret if(null(x), 0, diffSign(x, 1))
}

def negative (x) {
    # Alias
    ret lessZero(x)
}

def less (a, b) {
    ret lessZero(a - b)
}

def greaterEqualZero (x) {
    ret or(null(x), greaterZero(x))
}

def greaterEqual (a, b) {
    ret greaterEqualZero(a - b)
}

def lessEqualZero (x) {
    ret or(null(x), lessZero(x))
}

def lessEqual (a, b) {
    ret lessEqualZero(a - b)
}

def sign (x) {
    # x < 0  -> -1
    # x == 0 -> 0
    # x > 0  -> 1
    
    else_res = {
        ret = if(null(x), 0, 1)
    }
    
    ret if(negative(x), -1, else_res)
}

def max (a, b) {
    ret if(greater(a, b), a, b)
}

def min (a, b) {
    ret if(less(a, b), a, b)
}

def mod (a, b) {
    def positiveMod (a, b) {
        ret a - ((a // b) * b)
    }
    # TODO impl
    ret _if(negative(a), sub(b, sub(abs(a), mul(idiv(abs(a), b), b))), sub(a, mul(idiv(a, b), b)))
}

def floor (x) {
    ret sub(x, mod(x, 1))
}

def int (x) {
    ret sign(x) * floor(abs(x)))
}

# TODO left it here
def ceil (x) {
    ret _if(equalNumber(_int(x), x), x, add(floor(x), 1))
}

def decimal (x) {
}
    ret sub(x, _int(x))

def round (x) {
}
    ret mul(sign(x), _if(less(decimal(abs(x)), 0.5), _int(abs(x)), add(_int(abs(x)), 1)))

def divisible (a, b) {
}
    ret null(mod(a, b))

def even (x) {
}
    ret divisible(x, 2)

def odd (x) {
}
    ret _not(even(x))

def fizzBuzz (n) {

}

# FizzBuzz, evaluates to 3 if the number is devisable by 5 and 3, to 2 if divisible only by 5, to 1 if divisible only by 3, and to 0 otherwise
number = 15
program = _if(_and(divisible(number, 5), divisible(number, 3)), 3, _if(divisible(number, 5), 2, _if(divisible(number, 3), 1, 0)))
