TRUE = 1
FALSE = 0

def bool (x) {
    # TODO impl, parse as bool
}

def sqrt (x) {
    ret x ^ 0.5
}

def abs (x) {
    ret sqrt(x ^ 2)
}

def equalZero (x) {
    # The backbone of this whole thing ðŸ˜‚
    
    def positiveMod (a, b) {
        ret a - ((a // b) * b)
    }
    
    def positiveFloor (x) {
        ret x - positiveMod(x, 1)
    }
    
    def function (x) {
        ret abs(x) / (abs(x) +10) # 10 for "damping", could do with any positive value
    }
    
    ret positiveFloor(1 -function(x))
}

def null (x) {
    # An alias
    ret equalZero(x)
}

def not (bool) {
    ret (bool - 1) / -1
}

def diffNumber (a, b) {
    ret not(null(a - b))
}

def equalNumber (a, b) {
    ret not(diffNumber(a, b))
}

def if (bool, a, b) {
    ret (bool * a) - (bool - 1) * b
}

def and (bool_1, bool_2) {
    ret bool_1 * bool_2
}

def or (bool_1, bool_2) {
    both_zero = and(null(bool_1), null(bool_2))
    ret if(both_zero, 0, 1)
}

def xor (bool_1, bool_2) {
    ret if(and(bool_1, bool_2), 0, or(bool_1, bool_2))
}

def nand (bool_1, bool_2) {
    ret not(and(bool_1, bool_2))
}

def nor (bool_1, bool_2) {
    ret not(or(bool_1, bool_2))
}

def xnor (bool_1, bool_2) {
    ret not(xor(bool_1, bool_2))
}

def diffSign (a, b) {
    # negative, positive or null
    
    both_zero = and(null(a), null(b))
    
    else_res = {
        one_zero = or(null(a), null(b))
        
        ret if(one_zero, 1, {
            diffNumber(a * b, abs(a) * abs(b))
        })
    }
    
    ret if(both_zero, 0, else_res)
}

def sameSign (a, b) {
    ret not(diffSign(a, b))
}

def greaterZero (x) {
    ret if(null(x), 0, diffSign(x, -1))
}

def positive (x) {
    # Alias
    ret greaterZero(x)
}

def greater (a, b) {
    ret greaterZero(a - b)
}

def lessZero (x) {
    ret if(null(x), 0, diffSign(x, 1))
}

def negative (x) {
    # Alias
    ret lessZero(x)
}

def less (a, b) {
    ret lessZero(a - b)
}

def greaterEqualZero (x) {
    ret or(null(x), greaterZero(x))
}

def greaterEqual (a, b) {
    ret greaterEqualZero(a - b)
}

def lessEqualZero (x) {
    ret or(null(x), lessZero(x))
}

def lessEqual (a, b) {
    ret lessEqualZero(a - b)
}

def sign (x) {
    # x < 0  -> -1
    # x == 0 -> 0
    # x > 0  -> 1
    
    else_res = {
        ret if(null(x), 0, 1)
    }
    
    ret if(negative(x), -1, else_res)
}

def max (a, b) {
    ret if(greater(a, b), a, b)
}

def min (a, b) {
    ret if(less(a, b), a, b)
}

def mod (a, b) {
    #def positiveMod (a, b) {
    #    ret a - ((a // b) * b)
    #}
    # TODO impl
    ret if(
        negative(a),
        b - (abs(a) - ((abs(a) // b) * b)),
        a - ((a // b) * b)
    )
}

def floor (x) {
    ret x - mod(x, 1)
}

def int (x) {
    ret sign(x) * floor(abs(x))
}

def ceil (x) {
    ret if(equalNumber(int(x), x), x, floor(x) + 1)
}

def decimal (x) {
    ret x - int(x)
}

#def round (x) {
#    ret mul(sign(x), _if(less(decimal(abs(x)), 0.5), _int(abs(x)), add(_int(abs(x)), 1)))
#}

def divisible (a, b) {
    ret null(mod(a, b))
}

def even (x) {
    ret divisible(x, 2)
}

def odd (x) {
    ret not(even(x))
}

def fizzBuzz (n) {

}
