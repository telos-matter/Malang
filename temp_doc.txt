Precedence order is PEMDAS (), ^, */ //, +-

Parenthesis can span lines
Var assign ends with new line unless parenthensis
Parens can span multiple lines, but ops are in same line
; terminates expressions

Vars are case sensitive


def func (
These need be like this, ) {} can span lines 


A function is only defined when it hits the } 

You can define functions inside functions with same name? Yes

File includes are literally just includes, it is as if you took that file and pasted it there


Anonymous functions are block of code that are executed and have their own scope with their own res, is a value element and an instruction node



Once if implemented I think that both, pretty sure *,  both if and the else will be executed, and thus the state of the vars is always updated, its the return value that changes



In the same scope two functions can't have the same name. A scope is entered on each new function or anon_function


Also I wanna add a ret keyword that either returns what's in front of it or res if nothing in front


Negative number exists as they re so -5^2 == 25 but - 5^2 is -25

Alias func_call can't be on a new instruction (just for ease of dev and also makes alaises nicer)

Alises take all of what's on the left and what's immediately on the right

Strings are lists , with ""
'' Are chars, basically numbers
N they are just syntactic sugaring 

I plan on adding for loop, which would also just be syntactic sugaring, but its boundries are evaluated at rundtime

Include now skips already imported





How strings would be structured:
Goals:
Be able to store and show strings, only interested in ascii chars, which are 1 byte long, 8 bits, or 2 hex values (from 0 to 255). Also possibility to concat strings. Transfer numbers into strings and vice versa.

Attempt number 1:
Store the ascii chars as 3 digits numbers one after the other.
For example `Hello` would be `72, 101, 108, 108, 111` as one whole number. So `72101108108111`
Can store; if size not a multiple of 3, pad with 0 on the left
Can concat strings, simply move to left by 3 and add a char
Numbers to strings and Strings to number; a linear mapping function 

Works, but I fell like we can do better on terms of storage size if we store them as bytes
Attempt number 2:
Wait that's the same thing.
My idea was to store for example `el`, which would be `101, 108` as it would actually be stored like so: `0110 0101, 0110 1100` and then store what ever number that would represent that. But the number that would represent that is indeed `101108`. No wait that's not true. It's actually `25964` which is less. But wouldn't the benefit always be just 7 bit max?

`Hello` stored as bits would be `310939249775`. Which is stored on 40 bits, where as `72101108108111` is stored on 47 XD. If I can prove that it is indeed 7 bits, or even 1 byte more for any case then there is no need to go with the second one, and lets just go instead with the first attempt because its easier. And offers readability to the user too.

Okay so to store 2 chars, we need 2 bytes, one after the other. And to store 2 chars in the form of numbers, we need 2 numbers, one after the other. These numbers are of maximum 255, so the max 1 number can take is 1 byte, it would seem intuitive to say that 2 would take 2 bytes max. So 255255 shouldn't take more than 2 bytes u say. But what u overlook in that one is that although u just shift the number by 3 (1000), u are shifting it in base 10, which overshoots the 4 bits shifting (just 2**8 = 256). And 255000 alone is stored on 18 bits. Also why its works with 2 bytes and you can just shift, is because the value of the byte it self does not change because its already in base 2. 

So, in conclusion: we store each chars with their number representation, but we don't shift with 1000, but rather with 256. Done.
One last thing tho. The padding? No need, keep dividing by 256 until zero
Also, there is no difference between empty string and string containing \0


For loops are just syntactic sugaring and they just get expanded at compilation. 
Syntax is as follows:
for (var:begin:end:step)
{}
Or for (var:begin:end) {} 
Step is optional
For loops bounds are included, but basically, it keeps adding the step until its less than or equal
Or if the step is negative keeps on subtracting until greater than or equal
Since they get computed at runtime / compile time, you can make them behave like actual if statments
So they are really exotic compared to the rest of the lang

For loops can now have just end index

The doc is not all uptodate and has contradictions

Any functions called main that is encountered in the main scope gets unwrapped (and thus not added to the function definitions) and executed with what ever args were provided to fit the parameters. If missing parameters invalid code