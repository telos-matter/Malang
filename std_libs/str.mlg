# String library

include std

# API note:
#   - Strings can be of any length, however, the
#   function len will return -1 for any
#   string longer than MAX_LEN
#   (a value defined in the function). Subsequently any function
#   that uses the function len won't work with
#   strings longer than MAX_LEN.
#   It is mentioned, whenever that is the case.
#   Feel free to change the value of MAX_LEN,
#   the value chosen is arbitrary, but the
#   bigger the slower
#
#   - Empty strings don't actually exists,
#   and technically then length of a string
#   containing only the null
#   char is 1. But the len function implicitly
#   checks if it's the case and returns 0. So
#   "empty" strings, and strings containing
#   only '\0', and the value 0 are synonymous
#
#   - Also strings' index is 1-based. Why? Because I wanted to. What are you going to do about it, cry to ur mom? (But seriously tho, because it is easier. Also reinforces the fact that loops are inclusive, and also there is no lists so it's actually better that way I'd say)

# API implementation:
#   Some of the function that are defined in the standard library are redefined
#   here (but only inside function, so they are invisible outside)
#   in order for the functions to work (because of float limitations in
#   the abs function I guess? Not 100% sure). And namely they
#   are redefined to take into consideration that
#   they will be working with non-negative numbers
#   only, e.i. positive or null. N.N.: Non-Negative


def len(str) {
    # Returns the length of a string.
    # Returns -1 if the len is greater than MAX_LEN

    # Defining needed functions
    def NNNull (x) {
        def NNMod (a, b) {
            ret a - ((a // b) * b)
        }
        
        def NNFloor (x) {
            ret x - NNMod(x, 1)
        }
        
        def function (x) {
            ret x / (x +10)
        }
        
        ret NNFloor(1 -function(x))
    }

    $!
    def not (bool) {
        ret (bool - 1) / -1
    }

    @==
    def NNEqualNumber (a, b) {
        ret NNNull(a - b)
    }

    # The len function
    for (i: 0: 1000) { # for (i: 0: MAX_LEN). Calls to this function won't give results larger than that. Don't make it a variable so that the loops get expanded once
        
        for ($! (str @== 0): 0) { # Real if statement. If you feel that that's cheating, the commented code version below works too. But does not return -1 for values greater than MAX_LEN
            ret i
        }
        
        str = str // 256 # // 256 == // 2^8 == >> 8
    }
    ret -1

    # for (i: 1: 1000) {
    #     res = if (str @== 0, res, i)
    #     str = str // 2^8
    # }
}

# API limitation: str can't be longer than MAX_LEN
def charAt (str, i) {
    @%
    def NNMod (a, b) { # Remove this function and include the std library if you want to see why I redefined them
        ret a - ((a // b) * b)
    }

    for (len(str) -i) {
        str = str // 256
    }
    ret str @% 256
}

# TODO add substring

# TODO add index

# TODO add @in (contains)

# API limitation: length of str_2 can't be longer than MAX_LEN
@+
def append (str_1, str_2) {
    # Appends str_2 at the end of str_1
    ret (str_1 * 2^(8 * len(str_2))) + str_2
}

# API limitation: str can't be longer than MAX_LEN
def atoi (str) {
    # From ASCII to Integer
    for (i: 1: len(str)) {
        res = (res * 10) + charAt(str, i) - 48
    }
}

# API limitation: absolute value of int can't be larger than 10^1000
def itoa (int) {
    # From Integer to ASCII

    def intLen(int) {
        # Returns how many digits are in the integer. No more than 10^1000
        len = 0
        for (i: 1: 1000) {
            int = int // 10
            len = if (int @== 0, len, i)
        }
        ret len +1
    }

    str = if(negative(int), '-', 0)
    int = abs(int)
    len = intLen(int)
    for (i: 0: len - 1: -1) {
        digit = (int // 10^i) @% 10
        str = str @+ (digit +48)
    }
    
    ret str
}

# API limitation: the str you print every time can't be longer than MAX_LEN
def print (str, end) {
    # Keeps appending to the external res, so res shouldn't be used for anything else.
    ext res = ext_res @+ str @+ end
}

# API limitation: the str you print every time can't be longer than MAX_LEN
def print (str) {
    # Calls print with new line
    res = ext_res
    print(str, '\n')
    ext res = res 
}
