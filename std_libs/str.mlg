# String library

include std

# API note:
#   - Strings can be of any length, however, the
#   function len will return -1 for any
#   string longer than MAX_LEN
#   (a value defined in the function). Subsequently any function
#   that uses the function len won't work with
#   strings longer than MAX_LEN.
#   It is mentioned, whenever that is the case.
#   Feel free to change the value of MAX_LEN,
#   the value chosen is arbitrary, but the
#   bigger the slower
#
#   - Empty strings don't actually exists,
#   and technically then length of a string
#   containing only the null
#   char is 1. But the len function implicitly
#   checks if it's the case and returns 0. So
#   "empty" strings, and strings containing
#   only '\0', and the value 0 are synonymous
#
#   - Also strings' index is 1-based. Why? Because I wanted to. What are you going to do about it, cry to ur mom? (But seriously tho, because it is easier. Also reinforces the fact that loops are inclusive, and also there is no lists so it's actually better that way I'd say)
#   - Can only have ascii chars

# API implementation:
#   Some of the function that are defined in the standard library are redefined
#   here (but only inside function, so they are invisible outside)
#   in order for the functions to work (because of float limitations in
#   the abs function I guess? Not 100% sure). And namely they
#   are redefined to take into consideration that
#   they will be working with non-negative numbers
#   only, e.i. positive or null. N.N.: Non-Negative


def same (str_1, str_2) {
    # Returns TRUE if `str_1` is the same as `str_2`, FALSE otherwise.    

    # Defining needed functions
    def abs (x) {
        ret (x^2)^0.5
    }

    def null (x) {
        def NNMod (a, b) {
            ret a - ((a // b) * b)
        }
        
        def NNFloor (x) {
            ret x - NNMod(x, 1)
        }
        
        def function (x) {
            abs_x = abs(x)
            ret abs_x / (abs_x +10)
        }
        
        ret NNFloor(1 -function(x))
    }

    @==
    def equalNumber (a, b) {
        ret null(a - b)
    }

    ret str_1 @== str_2 # Two strings are the same if they are the same number
}

def empty (str) {
    # Returns TRUE if `str` is empty (length == 0), FALSE otherwise.

    ret same(str, "")
}

def len(str) {
    # Returns the length of a string. The string can't be longer than MAX_LEN == 1000

    # Needed function
    $!
    def not (bool) {
        ret (bool - 1) / -1
    }

    for (i: 0: 1000) { # for (i: 0: MAX_LEN). Calls to this function won't give results larger than MAX_LEN. Don't make MAX_LEN a variable so that the loops get expanded once.
        
        for (_: $! empty(str): 0) { # Real if statement. If you feel that that's cheating, the commented version of this code below does the same. But this is faster
            ret i
        }
        
        str = str // 256 # x // 256 is x // 2^8 is x >> 8
    }
    # Raise an exception because the length of the string is greater than MAX_LEN
    ret 0/0 

    # for (i: 1: 1000) {
    #     res = if (empty(str), res, i)
    #     str = str // 2^8
    # }
    # _ = 0/empty(str)
}

def append (str_1, str_2, str_2_len) {
    # Appends `str_2` with length `str_2_len` at the end of `str_1`
    ret (str_1 * 2^(8 * str_2_len)) + str_2
}

# API limitation: `str_2` can't be longer than MAX_LEN
@+
def append (str_1, str_2) {
    # Appends `str_2` at the end of `str_1`
    ret append(str_1, str_2, len(str_2))
}

def charAt (str, i, len) {
    # Returns the char at `i` in the string `str` with length `len`.
    # String indexing is 1-based

    # Needed function
    @%
    def NNMod (a, b) {
        ret a - ((a // b) * b)
    }

    str = str // (256 ^ (len - i))
    ret str @% 256
}

# API limitation: `str` can't be longer than MAX_LEN
def charAt (str, i) {
    # Returns the char at `i` in the string `str`.
    # String indexing is 1-based

    ret charAt(str, i, len(str))
}

# TODO add substring

# TODO add index

# TODO add reverse

# TODO add @in (contains)

def atoi (str, len) {
    # Parses the ASCII string `str` with length `len` to an integer

    # Needed function
    def if (bool, a, b) {
        ret (bool * a) - (bool - 1) * b
    }

    negative = same('-', charAt(str, 1, len))
    start = if(negative, 2, 1)
    for (i: start: len) {
        # Shift to the left and subtract the ASCII code for 0
        res = (res * 10) + charAt(str, i, len) - '0'
    }
    ret if(negative, -1 * res, res)
}

# API limitation: length of `str` can't be longer than MAX_LEN
def atoi (str) {
    # Parses the ASCII string `str` to an integer
    ret atoi(str, len(str))
}

# API limitation: absolute value of int can't be larger than 10^1000
def itoa (int) {
    # From Integer to ASCII

    def intLen(int) {
        # Returns how many digits are in the integer. No more than 10^1000
        len = 0
        for (i: 1: 1000) {
            int = int // 10
            len = if (int @== 0, len, i)
        }
        ret len +1
    }

    str = if(negative(int), '-', 0)
    int = abs(int)
    len = intLen(int)
    for (i: 0: len - 1: -1) {
        digit = (int // 10^i) @% 10
        str = str @+ (digit +48)
    }
    
    ret str
}

# API limitation: the str you print every time can't be longer than MAX_LEN
def print (str, end) {
    # Keeps appending to the external res, so res shouldn't be used for anything else.
    ext res = ext_res @+ str @+ end
}

# API limitation: the str you print every time can't be longer than MAX_LEN
def print (str) {
    # Calls print with new line
    res = ext_res
    print(str, '\n')
    ext res = res 
}
