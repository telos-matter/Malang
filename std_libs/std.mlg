# The standard library.
# Has the basic functions to get you going, as well as some nessaisary basic math function

FALSE = 0
TRUE = 1

def sqrt (x) {
    ret x ^ 0.5
}

def abs (x) {
    ret sqrt(x ^ 2)
}

def null (x) {
    # Checks if a number is null, a.k.a equal to zero
    # Also the backbone of this whole thing
    
    def NNMod (a, b) {
        ret a - ((a // b) * b)
    }
    
    def NNFloor (x) {
        ret x - NNMod(x, 1)
    }
    
    def function (x) {
        ret abs(x) / (abs(x) +10) # 10 for "damping", could do with any positive value
    }
    
    ret NNFloor(1 -function(x))
}

$!
def not (bool) {
    ret (bool - 1) / -1
}

def parseBool (n) {
    # 0 -> False, anything else -> True
    ret $! null(n)
}

@==
def equalNumber (a, b) {
    ret null(a - b)
}

@!=
def diffNumber (a, b) {
    ret $! null(a - b)
}

def if (bool, a, b) {
    # If bool is true return a otherwise return b
    ret (bool * a) - (bool - 1) * b
}

@&
def and (bool_1, bool_2) {
    ret bool_1 * bool_2
}

@|
def or (bool_1, bool_2) {
    both_zero = null(bool_1) @& null(bool_2)
    ret if(both_zero, 0, 1)
}

@^
def xor (bool_1, bool_2) {
    ret if(
        bool_1 @& bool_2,
        0,
        bool_1 @| bool_2)
}

@!&
def nand (bool_1, bool_2) {
    ret $! (bool_1 @& bool_2)
}

@!|
def nor (bool_1, bool_2) {
    ret $! (bool_1 @| bool_2)
}

def xnor (bool_1, bool_2) {
    ret $! (bool_1 @^ bool_2)
}

def diffSign (a, b) {
    # negative, positive or null
    
    both_zero = null(a) @& null(b)
    
    else_res = {
        one_zero = null(a) @| null(b)
        
        ret if(
            one_zero,
            1,
            (a * b) @!= (abs(a) * abs(b)))
    }
    
    ret if(both_zero, 0, else_res)
}

def sameSign (a, b) {
    ret $! diffSign(a, b)
}

def positive (x) {
    # Checks if a number is positive: x > 0
    ret if(
        null(x),
        0,
        diffSign(x, -1))
}

@>
def greater (a, b) {
    ret positive(a - b)
}

def negative (x) {
    # Checks if a number is negative: x < 0
    ret if(
        null(x),
        0,
        diffSign(x, 1))
}

@<
def less (a, b) {
    ret negative(a - b)
}

@>=
def greaterEqual (a, b) {
    def greaterEqualZero (x) {
        ret null(x) @| positive(x)
    }
    
    ret greaterEqualZero(a - b)
}

@<=
def lessEqual (a, b) {
    def lessEqualZero (x) {
        ret null(x) @| negative(x)
    }
    
    ret lessEqualZero(a - b)
}

def sign (x) {
    # x < 0  -> -1
    # x == 0 -> 0
    # x > 0  -> 1
    
    else_res = {
        ret if(null(x), 0, 1)
    }
    
    ret if(negative(x), -1, else_res)
}

def max (a, b) {
    ret if(a @> b, a, b)
}

def min (a, b) {
    ret if(a @< b, a, b)
}

@%
def mod (a, b) {
    def NNMod (a, b) {
        ret a - ((a // b) * b)
    }
    
    ret if(
        negative(a),
        {
            a = abs(a)
            ret b - NNMod(a, b)
        },
        NNMod(a, b)
    )
}

def floor (x) {
    ret x - (x @% 1)
}

def int (x) {
    # Only the integer part
    ret sign(x) * floor(abs(x))
}

def ceil (x) {
    ret if(
        int(x) @== x,
        x,
        floor(x) + 1)
}

def decimal (x) {
    # Only the decimal part
    ret x - int(x)
}

def round (x) {
    sign = sign(x)
    x = abs(x)
    ret sign * if(
                decimal(x) @< 0.5,
                int(x),
                int(x) + 1)
}

@/?
def divisible (a, b) {
    ret null(a @% b)
}

def even (x) {
    ret x @/? 2
}

def odd (x) {
    ret $! even(x)
}

$++
def inc (x) {
    ret x + 1
}

$--
def dec (x) {
    ret x - 1
}
